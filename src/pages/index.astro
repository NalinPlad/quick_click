---
import "../styles/global.css";
---

<html lang="en" class="bg-blue-200">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Quick Click</title>
	</head>
	<body class="flex flex-col items-center p-8 gap-8">
		<h1 class="text-indigo-600 text-5xl font-serif font-bold p-4">Quick <span class="text-blue-600">Click</span></h1>
		<div class="w-64">
			<label for="level-select" class="block text-gray-700 font-bold mb-2 text-center">Select Level</label>
			<input id="level-select" type="range" min="1" max="4" value="1" class="w-full h-2 bg-indigo-600 rounded-lg appearance-none cursor-pointer [&::-webkit-slider-thumb]:w-6 [&::-webkit-slider-thumb]:h-6 [&::-webkit-slider-thumb]:bg-white [&::-webkit-slider-thumb]:border-4 [&::-webkit-slider-thumb]:border-indigo-600 [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:appearance-none [&::-moz-range-thumb]:w-6 [&::-moz-range-thumb]:h-6 [&::-moz-range-thumb]:bg-white [&::-moz-range-thumb]:border-4 [&::-moz-range-thumb]:border-indigo-600 [&::-moz-range-thumb]:rounded-full">
			<div class="flex justify-between text-sm text-gray-700 px-1 mt-2 font-bold">
				<span>3x3</span>
				<span>4x4</span>
				<span>5x5</span>
				<span>6x6</span>
			</div>
		</div>

		<div class="flex items-center gap-8">
			<div id="hoverspot" class="w-16 h-16 bg-white border-4 border-indigo-200 hover:border-indigo-600 rounded-lg cursor-pointer transition-colors duration-200 flex items-center justify-center opacity-75 hover:opacity-100"><p>ðŸ™ˆ</p></div>
			
			<div class="relative">
				<p id="start-text" class="absolute font-bold inset-0 flex items-center justify-center bg-white/80 text-xl text-slate-600 rounded-lg z-10 text-center p-5">Hover the square to start pattern round</p>
				<div id="grid-container" class="w-[300px] h-[300px] bg-white rounded-lg shadow-lg p-4">
					<div id="grid" class="w-full h-full grid grid-cols-3 gap-1"></div>
				</div>
			</div>
			<div class="w-[150px] h-[300px] bg-white rounded-lg shadow-lg flex flex-col">
				<div class="bg-indigo-100 p-4 rounded-t-lg">
					<h2 id="round_time" class="text-xl font-bold text-slate-700">-</h2>
				</div>
				<div class="p-4" id="time_history"></div>
			</div>
		</div>
	</body>
</html>

<script>
const slider = document.getElementById('level-select');
const grid = document.getElementById('grid');
const hoverspot = document.getElementById('hoverspot');
const startText = document.getElementById('start-text');
const roundTime = document.getElementById('round_time');
const timeHistory = document.getElementById('time_history');

let correctPattern = [];
let playerPattern = [];
let cellsSelectable = false;
let stopwatchInterval;
let startTime;
let countdownInterval;

const baseCellBg = 'bg-indigo-100';
const revealedPatternCellBg = 'bg-indigo-500';
const playerSelectedCellBg = 'bg-indigo-400';
const commonCellClasses = ['rounded', 'transition-colors', 'duration-200', 'hover:bg-indigo-200'];

function createGrid(size) {
	grid.innerHTML = '';
	grid.className = `w-full h-full grid gap-1 grid-cols-${size} grid-rows-${size}`;
	const totalCells = size * size;
	for (let i = 0; i < totalCells; i++) {
		const cell = document.createElement('div');
		cell.classList.add(baseCellBg, ...commonCellClasses);
		cell.dataset.index = i;
		grid.appendChild(cell);
	}
}

function startStopwatch() {
	startTime = Date.now();
	stopwatchInterval = setInterval(() => {
		const elapsedTime = Date.now() - startTime;
		const seconds = (elapsedTime / 1000).toFixed(2);
		roundTime.textContent = `${seconds}s`;
	}, 10);
}

function stopStopwatch() {
	clearInterval(stopwatchInterval);
	const elapsedTime = Date.now() - startTime;
	const seconds = (elapsedTime / 1000).toFixed(2);
	roundTime.textContent = `${seconds}s`;
	return seconds;
}

let history = JSON.parse(localStorage.getItem('quickClickHistory')) || {
	'3': [], // 3x3 grid times
	'4': [], // 4x4 grid times
	'5': [], // 5x5 grid times
	'6': []  // 6x6 grid times
};

function addTimeToHistory(seconds) {
	const gridSize = parseInt(slider.value) + 2;
	
	// Add to history object
	history[gridSize].unshift(seconds);
	
	// Save to localStorage
	localStorage.setItem('quickClickHistory', JSON.stringify(history));

	// Update display
	if (!history[gridSize].slice(1).some(time => parseFloat(time) <= parseFloat(seconds))) {
		// It's a PB
		const timeEntry = document.createElement('div');
		timeEntry.className = 'text-indigo-600 font-bold mb-2';
		timeEntry.innerHTML = `${seconds}s <span class="ml-2 text-sm bg-blue-100 text-blue-800 px-2 py-0.5 rounded">PB</span>`;
		timeHistory.insertBefore(timeEntry, timeHistory.firstChild);
		return;
	}
	
	const timeEntry = document.createElement('div');
	timeEntry.className = 'text-slate-700 font-bold mb-2';
	timeEntry.textContent = `${seconds}s`;
	timeHistory.insertBefore(timeEntry, timeHistory.firstChild);
}

// Render existing times from history for current grid size
const currentGridSize = parseInt(slider.value) + 2;
const currentTimes = history[currentGridSize] || [];
currentTimes.forEach(time => {
	const timeEntry = document.createElement('div');
	timeEntry.className = 'text-slate-700 font-bold mb-2';
	timeEntry.textContent = `${time}s`;
	timeHistory.appendChild(timeEntry);
});


function startCountdown() {

	clearInterval(stopwatchInterval);
	const cells = Array.from(grid.children);
	cells.forEach(cell => {
		cell.classList.remove(revealedPatternCellBg, playerSelectedCellBg);
		if (!cell.classList.contains(baseCellBg)) {
			cell.classList.add(baseCellBg);
		}
	});
	correctPattern = [];
	playerPattern = [];

	let count = 2;
	startText.textContent = "ðŸŸ¡ ðŸŸ¡";
	countdownInterval = setInterval(() => {
		count--;
		if (count > 0) {
			startText.textContent = "ðŸŸ¡ ".repeat(count);
		} else {
			clearInterval(countdownInterval);
			startText.textContent = 'Hover the square to start pattern round';
			showPattern();
		}
	}, 1000);
}

function showPattern() {
	hideStartText();
	correctPattern = [];
	playerPattern = [];
	cellsSelectable = false;
	startStopwatch();

	const cells = Array.from(grid.children);
	cells.forEach(cell => {
		cell.classList.remove(revealedPatternCellBg, playerSelectedCellBg);
		if (!cell.classList.contains(baseCellBg)) {
			cell.classList.add(baseCellBg);
		}
	});

	const gridSize = parseInt(slider.value) + 2;
	const totalCells = gridSize * gridSize;
	const numToSelect = Math.floor(totalCells / 2);
	
	while (correctPattern.length < numToSelect) {
		const randomIndex = Math.floor(Math.random() * totalCells);
		if (!correctPattern.includes(randomIndex)) {
			correctPattern.push(randomIndex);
		}
	}

	correctPattern.forEach(index => {
		const cell = cells[index];
		if (cell) {
			cell.classList.replace(baseCellBg, revealedPatternCellBg);
		}
	});
}

function hidePatternAndAllowPlay() {
	const cells = Array.from(grid.children);
	correctPattern.forEach(index => {
		const cell = cells[index];
		if (cell && cell.classList.contains(revealedPatternCellBg)) {
			cell.classList.replace(revealedPatternCellBg, baseCellBg);
		}
	});
	cellsSelectable = true;
}

function handleCellClick(event) {
	if (!cellsSelectable || typeof event.target.dataset.index === 'undefined') return;

	const clickedCell = event.target;
	const cellIndex = parseInt(clickedCell.dataset.index);

	if (clickedCell.classList.contains(playerSelectedCellBg)) {
		clickedCell.classList.replace(playerSelectedCellBg, baseCellBg);
		playerPattern = playerPattern.filter(idx => idx !== cellIndex);
	} else if (clickedCell.classList.contains(baseCellBg)) {
		clickedCell.classList.replace(baseCellBg, playerSelectedCellBg);
		playerPattern.push(cellIndex);
	}
	checkWinCondition();
}

function hideStartText() {
	startText.style.display = 'none';
}

function showStartText() {
	startText.style.display = '';
}




function checkWinCondition() {
	if (correctPattern.length === 0) return;

	const sortedCorrect = [...correctPattern].sort((a, b) => a - b);
	const sortedPlayer = [...playerPattern].sort((a, b) => a - b);

	if (sortedCorrect.length === sortedPlayer.length && sortedCorrect.every((val, idx) => val === sortedPlayer[idx])) {
		const finalTime = stopStopwatch();
		addTimeToHistory(finalTime);
		cellsSelectable = false;
		showStartText()
		playerPattern = [];
	}
}

const initialGridSize = parseInt(slider.value) + 2;
createGrid(initialGridSize);

slider.addEventListener('input', (e) => {
	const size = parseInt(e.target.value) + 2;
	createGrid(size);
	showStartText();
	cellsSelectable = false;
	correctPattern = [];
	playerPattern = [];

	// Update time history display for selected grid size
	timeHistory.innerHTML = '';
	const times = history[size] || [];
	times.forEach(time => {
		const timeEntry = document.createElement('div');
		timeEntry.className = 'text-slate-700 font-bold mb-2';
		timeEntry.textContent = `${time}s`;
		timeHistory.appendChild(timeEntry);
	});

	roundTime.innerText = "-";
});

hoverspot.addEventListener('mouseenter', () => {
	showStartText();

	startCountdown();
});

hoverspot.addEventListener('mouseleave', () => {
	clearInterval(countdownInterval);
	startText.textContent = 'Hover the square to start pattern round';
	hidePatternAndAllowPlay();
});

grid.addEventListener('click', handleCellClick);
</script>